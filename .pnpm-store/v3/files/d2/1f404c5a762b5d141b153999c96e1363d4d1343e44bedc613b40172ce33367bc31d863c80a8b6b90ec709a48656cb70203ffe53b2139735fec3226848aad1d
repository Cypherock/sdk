import { EOL } from 'os';
import ts from 'typescript';
import { CheckStatus } from '@stryker-mutator/api/check';
import { tokens, commonTokens, Scope } from '@stryker-mutator/api/plugin';
import { split, strykerReportBugUrl } from '@stryker-mutator/util';
import * as pluginTokens from './plugin-tokens.js';
import { TypescriptCompiler } from './typescript-compiler.js';
import { createGroups } from './grouping/create-groups.js';
import { toPosixFileName } from './tsconfig-helpers.js';
import { HybridFileSystem } from './fs/hybrid-file-system.js';
typescriptCheckerLoggerFactory.inject = tokens(commonTokens.getLogger, commonTokens.target);
// eslint-disable-next-line @typescript-eslint/ban-types
function typescriptCheckerLoggerFactory(loggerFactory, target) {
    var _a;
    const targetName = (_a = target === null || target === void 0 ? void 0 : target.name) !== null && _a !== void 0 ? _a : TypescriptChecker.name;
    const category = targetName === TypescriptChecker.name ? TypescriptChecker.name : `${TypescriptChecker.name}.${targetName}`;
    return loggerFactory(category);
}
create.inject = tokens(commonTokens.injector);
export function create(injector) {
    return injector
        .provideFactory(commonTokens.logger, typescriptCheckerLoggerFactory, Scope.Transient)
        .provideClass(pluginTokens.fs, HybridFileSystem)
        .provideClass(pluginTokens.tsCompiler, TypescriptCompiler)
        .injectClass(TypescriptChecker);
}
/**
 * An in-memory type checker implementation which validates type errors of mutants.
 */
export class TypescriptChecker {
    constructor(logger, options, tsCompiler) {
        this.logger = logger;
        this.tsCompiler = tsCompiler;
        this.options = options;
    }
    /**
     * Starts the typescript compiler and does a dry run
     */
    async init() {
        const errors = await this.tsCompiler.init();
        if (errors.length) {
            throw new Error(`Typescript error(s) found in dry run compilation: ${this.createErrorText(errors)}`);
        }
    }
    /**
     * Checks whether or not a mutant results in a compile error.
     * Will simply pass through if the file mutated isn't part of the typescript project
     * @param mutants The mutants to check
     */
    async check(mutants) {
        const result = Object.fromEntries(mutants.map((mutant) => [mutant.id, { status: CheckStatus.Passed }]));
        // Check if this is the group with unrelated files and return check status passed if so
        if (!this.tsCompiler.nodes.get(toPosixFileName(mutants[0].fileName))) {
            return result;
        }
        const mutantErrorRelationMap = await this.checkErrors(mutants, {}, this.tsCompiler.nodes);
        for (const [id, errors] of Object.entries(mutantErrorRelationMap)) {
            result[id] = { status: CheckStatus.CompileError, reason: this.createErrorText(errors) };
        }
        return result;
    }
    /**
     * Creates groups of the mutants.
     * These groups will get send to the check method.
     * @param mutants All the mutants to group.
     */
    async group(mutants) {
        if (!this.options.typescriptChecker.prioritizePerformanceOverAccuracy) {
            return mutants.map((m) => [m.id]);
        }
        const nodes = this.tsCompiler.nodes;
        const [mutantsOutsideProject, mutantsInProject] = split(mutants, (m) => nodes.get(toPosixFileName(m.fileName)) == null);
        const groups = createGroups(mutantsInProject, nodes);
        if (mutantsOutsideProject.length) {
            return [mutantsOutsideProject.map((m) => m.id), ...groups];
        }
        else {
            return groups;
        }
    }
    async checkErrors(mutants, errorsMap, nodes) {
        var _a, _b;
        const errors = await this.tsCompiler.check(mutants);
        const mutantsThatCouldNotBeTestedInGroups = new Set();
        //If there is only a single mutant the error has to originate from the single mutant
        if (errors.length && mutants.length === 1) {
            errorsMap[mutants[0].id] = errors;
            return errorsMap;
        }
        for (const error of errors) {
            if (!((_a = error.file) === null || _a === void 0 ? void 0 : _a.fileName)) {
                throw new Error(`Typescript error: '${error.messageText}' was reported without a corresponding file. This shouldn't happen. Please open an issue using this link: ${strykerReportBugUrl(`[BUG]: TypeScript checker reports compile error without a corresponding file: ${error.messageText}`)}`);
            }
            const nodeErrorWasThrownIn = nodes.get((_b = error.file) === null || _b === void 0 ? void 0 : _b.fileName);
            if (!nodeErrorWasThrownIn) {
                throw new Error(`Typescript error: '${error.messageText}' was reported in an unrelated file (${error.file.fileName}). This file is not part of your project, or referenced from your project. This shouldn't happen, please open an issue using this link: ${strykerReportBugUrl(`[BUG]: TypeScript checker reports compile error in an unrelated file: ${error.messageText}`)}`);
            }
            const mutantsRelatedToError = nodeErrorWasThrownIn.getMutantsWithReferenceToChildrenOrSelf(mutants);
            if (mutantsRelatedToError.length === 0) {
                // In rare cases there are no mutants related to the typescript error
                // Having to test all mutants individually to know which mutant thrown the error
                for (const mutant of mutants) {
                    mutantsThatCouldNotBeTestedInGroups.add(mutant);
                }
            }
            else if (mutantsRelatedToError.length === 1) {
                // There is only one mutant related to the typescript error so we can add it to the errorsRelatedToMutant
                if (errorsMap[mutantsRelatedToError[0].id]) {
                    errorsMap[mutantsRelatedToError[0].id].push(error);
                }
                else {
                    errorsMap[mutantsRelatedToError[0].id] = [error];
                }
            }
            else {
                // If there are more than one mutants related to the error we should check them individually
                for (const mutant of mutantsRelatedToError) {
                    mutantsThatCouldNotBeTestedInGroups.add(mutant);
                }
            }
        }
        if (mutantsThatCouldNotBeTestedInGroups.size) {
            //Because at this point the filesystem contains all the mutants from the group we need to reset back
            //to the original state of the files to make it possible to test the first mutant
            //if we wouldn't do this the first mutant would not be noticed by the compiler because it was already in the filesystem
            await this.tsCompiler.check([]);
        }
        for (const mutant of mutantsThatCouldNotBeTestedInGroups) {
            if (errorsMap[mutant.id])
                continue;
            await this.checkErrors([mutant], errorsMap, nodes);
        }
        return errorsMap;
    }
    createErrorText(errors) {
        return ts.formatDiagnostics(errors, {
            getCanonicalFileName: (fileName) => fileName,
            getCurrentDirectory: process.cwd,
            getNewLine: () => EOL,
        });
    }
}
/**
 * Keep track of all tsconfig files which are read during compilation (for project references)
 */
TypescriptChecker.inject = tokens(commonTokens.logger, commonTokens.options, pluginTokens.tsCompiler);
//# sourceMappingURL=typescript-checker.js.map