import path from 'path';
import ts from 'typescript';
import { propertyPath, Task } from '@stryker-mutator/util';
import { tokens, commonTokens } from '@stryker-mutator/api/plugin';
import { determineBuildModeEnabled, getSourceMappingURL, guardTSVersion, overrideOptions, retrieveReferencedProjects, toPosixFileName, } from './tsconfig-helpers.js';
import { TSFileNode } from './grouping/ts-file-node.js';
import * as pluginTokens from './plugin-tokens.js';
const FILE_CHANGE_DETECTED_DIAGNOSTIC_CODE = 6032;
export class TypescriptCompiler {
    constructor(log, options, fs) {
        this.log = log;
        this.options = options;
        this.fs = fs;
        this.currentTask = new Task();
        this.currentErrors = [];
        this.sourceFiles = new Map();
        this._nodes = new Map();
        this.lastMutants = [];
        this.tsconfigFile = toPosixFileName(this.options.tsconfigFile);
        this.allTSConfigFiles = new Set([path.resolve(this.tsconfigFile)]);
    }
    async init() {
        guardTSVersion();
        this.guardTSConfigFileExists();
        const buildModeEnabled = determineBuildModeEnabled(this.tsconfigFile);
        const host = ts.createSolutionBuilderWithWatchHost({
            ...ts.sys,
            readFile: (fileName) => {
                var _a;
                if (this.fileNameIsBuildInfo(fileName)) {
                    return undefined;
                }
                const content = (_a = this.fs.getFile(fileName)) === null || _a === void 0 ? void 0 : _a.content;
                if (content && this.allTSConfigFiles.has(path.resolve(fileName))) {
                    return this.adjustTSConfigFile(fileName, content, buildModeEnabled);
                }
                return content;
            },
            fileExists: (fileName) => {
                // We want to ignore the buildinfo files. With them the compiler skips the program part we want to use.
                if (this.fileNameIsBuildInfo(fileName)) {
                    return false;
                }
                return ts.sys.fileExists(fileName);
            },
            getModifiedTime: (fileName) => {
                var _a;
                if (this.fileNameIsBuildInfo(fileName)) {
                    return undefined;
                }
                return (_a = this.fs.getFile(fileName)) === null || _a === void 0 ? void 0 : _a.modifiedTime;
            },
            watchFile: (fileName, callback) => {
                const file = this.fs.getFile(fileName);
                if (file) {
                    file.watcher = callback;
                }
                return {
                    close: () => {
                        delete this.fs.getFile(fileName).watcher;
                    },
                };
            },
            writeFile: (fileName, data) => {
                this.fs.writeFile(fileName, data);
            },
            watchDirectory: () => {
                // this is used to see if new files are added to a directory. Can safely be ignored for mutation testing.
                return {
                    // eslint-disable-next-line @typescript-eslint/no-empty-function
                    close() { },
                };
            },
        }, (...args) => {
            const program = ts.createEmitAndSemanticDiagnosticsBuilderProgram(...args);
            if (this._nodes.size) {
                return program;
            }
            program
                .getSourceFiles()
                .filter(filterDependency)
                .forEach((file) => {
                this.sourceFiles.set(file.fileName, {
                    fileName: file.fileName,
                    imports: new Set(program
                        .getAllDependencies(file)
                        .filter((importFile) => !importFile.includes('/node_modules/') && file.fileName !== importFile)
                        .flatMap((importFile) => this.resolveTSInputFile(importFile))),
                });
            });
            function filterDependency(file) {
                if (file.fileName.endsWith('.d.ts') || file.fileName.includes('node_modules')) {
                    return false;
                }
                return true;
            }
            return program;
        }, (error) => {
            this.currentErrors.push(error);
        }, (status) => {
            this.log.debug(status.messageText.toString());
        }, (summary) => {
            summary.code !== FILE_CHANGE_DETECTED_DIAGNOSTIC_CODE && this.currentTask.resolve();
        });
        const compiler = ts.createSolutionBuilderWithWatch(host, [this.tsconfigFile], {});
        compiler.build();
        return await this.check([]);
    }
    async check(mutants) {
        this.lastMutants.forEach((mutant) => {
            const file = this.fs.getFile(mutant.fileName);
            file.resetMutant();
        });
        mutants.forEach((mutant) => {
            const file = this.fs.getFile(mutant.fileName);
            file.mutate(mutant);
        });
        await this.currentTask.promise;
        const errors = this.currentErrors;
        this.currentTask = new Task();
        this.currentErrors = [];
        this.lastMutants = mutants;
        return errors;
    }
    get nodes() {
        if (!this._nodes.size) {
            // create nodes
            for (const [fileName] of this.sourceFiles) {
                const node = new TSFileNode(fileName, [], []);
                this._nodes.set(fileName, node);
            }
            // set children
            for (const [fileName, file] of this.sourceFiles) {
                const node = this._nodes.get(fileName);
                if (node == null) {
                    throw new Error(`Node for file '${fileName}' could not be found. This should not happen. This shouldn't happen, please open an issue on the stryker-js github`);
                }
                const importFileNames = [...file.imports];
                node.children = importFileNames.map((importName) => this._nodes.get(importName)).filter((n) => n != undefined);
            }
            // set parents
            for (const [, node] of this._nodes) {
                node.parents = [];
                for (const [, n] of this._nodes) {
                    if (n.children.includes(node)) {
                        node.parents.push(n);
                    }
                }
            }
        }
        return this._nodes;
    }
    /**
     * Resolves TS input file based on a dependency of a input file
     * @param dependencyFileName The dependency file name. With TS project references this can be a declaration file
     * @returns TS source file if found (fallbacks to input filename)
     */
    resolveTSInputFile(dependencyFileName) {
        if (!dependencyFileName.endsWith('.d.ts')) {
            return dependencyFileName;
        }
        const file = this.fs.getFile(dependencyFileName);
        if (!file) {
            throw new Error(`Could not find ${dependencyFileName}`);
        }
        const sourceMappingURL = getSourceMappingURL(file.content);
        if (!sourceMappingURL) {
            return dependencyFileName;
        }
        const sourceMapFileName = path.resolve(path.dirname(dependencyFileName), sourceMappingURL);
        const sourceMap = this.fs.getFile(sourceMapFileName);
        if (!sourceMap) {
            this.log.warn(`Could not find sourcemap ${sourceMapFileName}`);
            return dependencyFileName;
        }
        const sources = JSON.parse(sourceMap.content).sources;
        if ((sources === null || sources === void 0 ? void 0 : sources.length) === 1) {
            const sourcePath = sources[0];
            return toPosixFileName(path.resolve(path.dirname(sourceMapFileName), sourcePath));
        }
        return dependencyFileName;
    }
    adjustTSConfigFile(fileName, content, buildModeEnabled) {
        const parsedConfig = ts.parseConfigFileTextToJson(fileName, content);
        if (parsedConfig.error) {
            return content; // let the ts compiler deal with this error
        }
        else {
            for (const referencedProject of retrieveReferencedProjects(parsedConfig, path.dirname(fileName))) {
                this.allTSConfigFiles.add(referencedProject);
            }
            return overrideOptions(parsedConfig, buildModeEnabled);
        }
    }
    guardTSConfigFileExists() {
        if (!ts.sys.fileExists(this.tsconfigFile)) {
            throw new Error(`The tsconfig file does not exist at: "${path.resolve(this.tsconfigFile)}". Please configure the tsconfig file in your stryker.conf file using "${propertyPath()('tsconfigFile')}"`);
        }
    }
    fileNameIsBuildInfo(fileName) {
        return fileName.endsWith('.tsbuildinfo');
    }
}
TypescriptCompiler.inject = tokens(commonTokens.logger, commonTokens.options, pluginTokens.fs);
//# sourceMappingURL=typescript-compiler.js.map